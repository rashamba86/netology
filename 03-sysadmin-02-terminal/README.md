1. Команда `cd` - это внутренняя (встроенная) команда bash, отвечает за смену текущей дериктории. Если бы эта команда была бы внешней для bash, то при смене директории запускалась бы другая сессия окружения, со своим сеансом bash. Также эта функция встечается в огромном количестве других программ, и случайное ее удаление нарушило бы работу этих программ. Так что нахождение программы внутри bash обеспечивает безопасность работоспособности окружения.
2. Вместо `grep <some_string> <some_file> | wc -l` можно использовать `grep <some_string> <some_file> -c`. Обе команды выводят на экран количество строк, в которых найдено совпадение `<some_string>` в `<some_file>`.
3. С помощью `pstree -p | grep \(1\)` найдем процесс с PID 1. Это `systemd`.
4. Находясь в `/dev/pts/1` вводим `ls -l /123 2> /dev/pts/2`. Этой командой перенаправляется вывод ошибок команды `ls` в `/dev/pts/2`. Т.к. каталог `123` отсутствует, то вывод ошибки в терминале `pts2` будет `ls: невозможно получить доступ к '/123': Нет такого файла или каталога`.
5. `cat 0< file_input.txt 1> file_output.txt` или не указывая дескрипторы `cat < file_input.txt > file_output.txt`.
6. Сначала необходимо залогиниться в `/dev/tty2` (ctrl+alt+F2). Затем вводим `ls -l ~ > /dev/tty2` и перенаправляем вывод `ls` в терминал `tty2`. Результат выполнения команды видим при переключении на терминал `2`.
7. Командой `bash 5>&1` создается дескриптор `5` и перенаправляется в `stdout`. Результатом введения команды `echo netology > /proc/$$/fd/5`, которая перенаправляет вывод команды `echo` в дескриптор `5`  будет `netology`, т.к ранее этот дескриптор был перенаправлен в `stdout`.
8. Создадим новый дескриптор и перенаправим в него `stderr`. Затем перенаправим последовательно `stderr` в `stdout`, `stdout` в созданный дескриптор. Передадим вывод команды в данную последовательность перенарпавлений: `ls 7>&2 2>&1 1>&7 /tpm | grep -c "No such"`. Получаем в ответ `1`, следовательно вывод ошибок работает.
9. Вывод `cat /proc/$$/environ` - переменные окружения. В качестве альтернативы можно использовать `printenv`.
10. Используя `man proc` и поиск по словам `/cmdline`, `/exe` узнаем, что `cmdline` - это файл (только для чтения), в котором хранится полный путь до файла процесса, за исключением процессов-зомби, а `exe` - это символьная ссылка на запущенную команду.
11. Процессор `Ryzen 2600` поддерживает инструкции `grep sse /proc/cpuinfo` - `sse4_2`, `sse4a`.
12. По-умолчанию, использую `ssh` для подключения к удаленной машине `tty` не определен для удаленной сессии. Необходимо использовать флаг `-t` для аллокации `tty`: `ssh -t localhost 'tty'`.
13. Согласно `man reptyr` сначала необходимо выполнить `echo 0 > /proc/sys/kernel/yama/ptrace_scope` либо внести изменения в файл `/etc/sysctl.d/10-ptrace.conf`: `kernel.yama.ptrace_scope = 0`. Эта возможность заблокированна с целью безопасности. Захожу на машину по ssh. Просматриваю запущенные процессы: `ps -a`:
    
        vagrant@vagrant:~$ ps -a
        PID TTY          TIME CMD
        1016 pts/0    00:00:00 ps
    Запускаю процесс 'nano' и сворачию его в бэкграунд `Ctrl + Z`. Повторяю просмотр запущенных процессов:
        
        vagrant@vagrant:~$ ps -a
        PID TTY          TIME CMD
        1020 pts/0    00:00:00 nano
        1021 pts/0    00:00:00 ps
    Запускаю `screen` и пробую перенести процесс `nano` в него: `reptyr 1020`. Процесс `nano` успешно развернулся внутри сессии `screen`.
14. Находять в `shell` под обычным пользователем у нас нет прав доступа к файлу `/root/new_file`, а т.к. `echo` - это не отдельная команда, а команда, встроенная в `shell`, то используя `sudo` нельзя наделить ее возможностями внести изменения в файл. При этом `tee` - это отдельная команда и используя `sudo` можем наделить ее правами доступа к файлу.
`tee` читает из `stdin` и пишет в `stdout` и в файлы.
